<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Network QoE Dashboard — Insightful (Compare + Worst Window + PDF)</title>

    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- jsPDF for PDF export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <!-- Favicon -->
    <link rel="icon" type="image/png" href="assets/logo.png" />
    <!-- OR for .ico format -->
    <link rel="icon" type="image/x-icon" href="assets/logo.png" />

    <style>
        :root {
            --bg: #f3f6fb;
            --card: #ffffff;
            --text: #082035;
            --muted: #6b7a90;
            --accent: #0b69ff;
            --success: #00b37e;
            --warn: #ff9f43;
            --danger: #ff4d4f;
            --glass: rgba(255, 255, 255, 0.6);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #e1e8fb;
                --card: #0b1220;
                --text: #e6f0ff !important;
                --muted: #98a3bf;
                --accent: #4da6ff;
                --glass: rgba(255, 255, 255, 0.03);
            }

            body {
                color: var(--text);
                background: linear-gradient(180deg, #041224 0%, #061426 100%);
            }
        }

        @media (prefers-color-scheme: light) {
            body {
                color: var(--text);
                background: var(--bg);
            }
        }

        * {
            box-sizing: border-box
        }

        body {
            margin: 0;
            font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial;
            padding: 22px;
            -webkit-font-smoothing: antialiased
        }

        .page {
            max-width: 1250px;
            margin: 0 auto
        }

        .header {
            display: flex;
            align-items: center;
            gap: 14px;
            padding: 12px;
            border-radius: 12px;
            background: linear-gradient(90deg, rgba(11, 105, 255, 0.06), rgba(0, 183, 126, 0.02));
            box-shadow: 0 8px 30px rgba(2, 10, 30, 0.06);
            margin-bottom: 16px;
            justify-content: center;
        }

        .logo {
            width: 44px;
            height: 44px;
            object-fit: contain;
            border-radius: 8px
        }

        .title-block h1 {
            margin: 0;
            font-size: 20px
        }

        .title-block .sub {
            font-size: 13px;
            color: var(--muted);
            margin-top: 6px
        }

        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
            margin-bottom: 16px;
            flex-wrap: wrap
        }

        .controls-left {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap
        }

        select,
        input[type=date] {
            padding: 8px 10px;
            border-radius: 8px;
            border: 1px solid rgba(0, 0, 0, 0.06);
            background: var(--card);
            min-width: 160px;
            color: white;
        }

        .btn {
            padding: 8px 12px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-weight: 700
        }

        .btn.primary {
            background: var(--accent);
            color: white
        }

        .btn.outline {
            background: transparent;
            border: 1px solid rgba(0, 0, 0, 0.06);
            color: var(--text)
        }

        /* layout */
        .grid {
            display: grid;
            gap: 14px
        }

        @media(min-width:1300px) {
            .grid {
                grid-template-columns: 1fr 420px;
            }
        }

        @media(max-width:1199px) {
            .grid {
                grid-template-columns: 1fr;
            }
        }

        .card {
            background: linear-gradient(180deg, var(--card), var(--glass));
            padding: 14px;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(2, 8, 20, 0.06);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .card h3 {
            margin: 0;
            font-size: 16px
        }

        .meta {
            font-size: 13px;
            color: var(--muted)
        }

        .two-col {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px
        }

        @media(max-width:880px) {
            .two-col {
                grid-template-columns: 1fr
            }
        }

        canvas {
            width: 100% !important;
            height: 170px !important;
            border-radius: 8px;
            background: transparent
        }

        .summary {
            padding: 10px;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.03);
            font-size: 14px;
            color: var(--muted);
            display: flex;
            flex-direction: column;
            gap: 6px
        }

        .summary .score {
            font-weight: 700
        }

        .recommend {
            color: var(--muted);
            font-size: 13px
        }

        .insight-tag {
            display: inline-block;
            padding: 6px 8px;
            border-radius: 999px;
            font-weight: 700;
            font-size: 13px
        }

        .good {
            background: rgba(0, 179, 126, 0.12);
            color: var(--success)
        }

        .ok {
            background: rgba(255, 159, 64, 0.08);
            color: var(--warn)
        }

        .bad {
            background: rgba(255, 77, 79, 0.08);
            color: var(--danger)
        }

        .compare-controls {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap
        }

        .small {
            font-size: 12px;
            color: var(--muted)
        }

        .full {
            grid-column: 1 / -1;
        }

        #loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            color: white;
            font-size: 16px;
        }

        .spinner {
            width: 48px;
            height: 48px;
            border: 4px solid #fff;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 12px;
        }

        @keyframes spin {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body>
    <div id="loader">
        <div class="spinner"></div>
        <p>Loading data…</p>
    </div>

    <div class="page">
        <div class="header">
            <img src="assets/logo.png" class="logo" alt="logo" />
            <div class="title-block">
                <h1>Network Pulse Test Suite Dashboard</h1>
                <div class="sub">Analytics • Compare users • Worst 10s highlights • Excel/Pdf Export</div>
            </div>
        </div>
        <div class="controls">
            <div class="controls-left">
                <label>User A:
                    <select id="userA"></select>
                </label>
                <label>User B:
                    <select id="userB">
                        <option value="none">None</option>
                    </select>
                </label>
                <label>From: <input id="fromDate" type="date" /></label>
                <label>To: <input id="toDate" type="date" /></label>
                <div class="compare-controls">
                    <button id="applyFilters" class="btn primary">Apply</button>
                    <button id="resetFilters" class="btn outline">Reset</button>
                </div>
            </div>
            <div>
                <button id="exportPdf" class="btn outline">Export PDF</button>
                <button id="downloadCsv" class="btn outline">Export CSV</button>
                <button id="refresh" class="btn outline">Refresh</button>
            </div>
        </div>

        <div class="grid">
            <div id="mainColumn">
                <!-- aggregated + per-test cards inserted here -->
            </div>

            <div id="sideColumn">
                <div class="card">
                    <h3>Quick Snapshot</h3>
                    <div id="snapshot" class="small">—</div>
                </div>
                <div class="card">
                    <h3>Legend / Notes</h3>
                    <div class="small">
                        • Worst 10s are highlighted on charts and mentioned in each summary.<br />
                        • Choose User B = None to disable comparison.
                    </div>
                </div>
            </div>
        </div>

    </div>

    <script>
        /* ------------------------------
          Config & Globals
           ------------------------------ */
        const API_URL = 'https://qoe-backend-zr50.onrender.com/api/users/results';
        let allData = [];
        const charts = {}; // store Chart.js instances keyed by id

        /* ------------------------------
          Utility functions
           ------------------------------ */
        function getVal(obj, keys, def = 0) {
            if (!obj) return def;
            for (const k of keys) if (obj[k] !== undefined) return obj[k];
            return def;
        }
        function sanitizeId(s) { return String(s || '').replace(/[@.]/g, '-').replace(/[^a-zA-Z0-9-_]/g, ''); }

        // parse ISO-ish ts to Date or null
        function toDate(t) { const d = t ? new Date(t) : null; return (d && !isNaN(d)) ? d : null; }

        // series extraction (keeps ordering)
        function seriesFor(records, path) {
            const arr = records.slice().sort((a, b) => (toDate(a.ts) || 0) - (toDate(b.ts) || 0));
            const out = [];
            for (const r of arr) {
                let val = r;
                for (const k of path) { if (val) val = val[k]; else break; }
                const t = toDate(r.ts);
                if (t && val !== undefined && val !== null && !isNaN(Number(val))) out.push({ t, v: Number(val), raw: r });
            }
            return out;
        }

        // compute averages
        function computeAverages(records) {
            const avg = {
                voip: { MOS: 0, latencyMs: 0, jitter: 0, packetsLost: 0 },
                local: { startup: 0, avgBufferAhead: 0, freezeCount: 0 },
                youtube: { startup: 0, freezeCount: 0, freezeDuration: 0 },
                speed: { download: 0, upload: 0 }
            };
            const n = records.length || 1;
            records.forEach(r => {
                avg.voip.MOS += getVal(r.voip, ['MOS', 'mos']);
                avg.voip.latencyMs += getVal(r.voip, ['latencyMs', 'latency']);
                avg.voip.jitter += getVal(r.voip, ['avgJitterMs', 'jitter']);
                avg.voip.packetsLost += getVal(r.voip, ['packetsLost', 'loss', 'lossPercent']);
                avg.local.startup += getVal(r.local, ['startup']);
                avg.local.avgBufferAhead += getVal(r.local, ['avgBufferAhead']);
                avg.local.freezeCount += getVal(r.local, ['freezeCount', 'stalls']);
                avg.youtube.startup += getVal(r.youtube, ['startup']);
                avg.youtube.freezeCount += getVal(r.youtube, ['freezeCount', 'stalls']);
                avg.youtube.freezeDuration += getVal(r.youtube, ['freezeDuration', 'totalStall']);
                avg.speed.download += getVal(r.speed, ['download']);
                avg.speed.upload += getVal(r.speed, ['upload']);
            });
            Object.keys(avg).forEach(k => {
                Object.keys(avg[k]).forEach(f => {
                    avg[k][f] = +(avg[k][f] / n).toFixed(2);
                    if (isNaN(avg[k][f])) avg[k][f] = 0;
                });
            });
            return avg;
        }

        /* ------------------------------
          Worst 10-second window detection
           - takes a series of points [{t:Date, v:Number, raw}]
           - returns {start, end, score, points}
           - scoring: normalize v by its range then sum -> highest indicates worst.
           ------------------------------ */
        function worstWindow(points, seconds = 10) {
            if (!points || points.length === 0) return null;
            // simple score: for window compute sum of v (higher worse for latency/freeze/duration)
            let best = { score: -Infinity, start: null, end: null, points: [] };
            let i = 0, j = 0, sum = 0;
            while (i < points.length) {
                const startT = points[i].t;
                // move j so points[j].t <= startT + seconds
                while (j < points.length && (points[j].t - startT) <= seconds * 1000) {
                    sum += points[j].v;
                    j++;
                }
                if (sum > best.score) {
                    best.score = sum;
                    best.start = startT;
                    best.end = points[Math.max(0, j - 1)].t;
                    best.points = points.slice(i, j);
                }
                // advance i (remove its value)
                sum -= points[i].v;
                i++;
            }
            if (best.score === -Infinity) return null;
            return best;
        }

        /* ------------------------------
          Chart helpers (handles single point)
           ------------------------------ */
        function drawLine(ctxId, points, label, yLabel, highlightWindow = null, color = "#3b82f6") {
            const canvas = document.getElementById(ctxId);
            if (!canvas) return null;
            if (canvas._chart) try { canvas._chart.destroy(); } catch (e) { }
            const labels = points.map(p => p.t.toLocaleTimeString());
            const data = points.map(p => p.v);
            // handle single-point: duplicate label for display
            const displayLabels = labels.length === 1 ? [labels[0], labels[0]] : labels;
            const displayData = data.length === 1 ? [data[0], data[0]] : data;

            const datasets = [{ label, data: displayData, fill: false, tension: 0.25, pointRadius: 3, borderWidth: 2, borderColor: color }];
            // if highlight window exists, add dataset overlay of highlight points
            if (highlightWindow && highlightWindow.points && highlightWindow.points.length) {
                const winLabels = displayLabels.map(l => null);
                const winData = displayData.map(_ => null);
                // mark indices of highlight in original points
                highlightWindow.points.forEach(pt => {
                    // find matching index in points (first equal time)
                    const idx = points.findIndex(p => p.t.getTime() === pt.t.getTime() && p.v === pt.v);
                    if (idx >= 0) {
                        // map to display index (account for duplication)
                        winData[idx] = displayData[idx];
                        winLabels[idx] = displayLabels[idx];
                    }
                });
                datasets.push({ label: label + " (worst)", data: winData, type: 'line', pointRadius: 4, borderWidth: 0, backgroundColor: 'rgba(255,99,132,0.2)', showLine: false });
            }

            const chart = new Chart(canvas, {
                type: 'line',
                data: { labels: displayLabels, datasets },
                options: {
                    responsive: true,
                    plugins: { legend: { display: false } },
                    scales: { y: { beginAtZero: true, title: { display: !!yLabel, text: yLabel } } }
                }
            });
            canvas._chart = chart;
            return chart;
        }

        /* ------------------------------
          Summaries / recommendations
           ------------------------------ */
        function makeSummaries(avg, seriesMap) {
            // avg is aggregated averages; seriesMap may include worst window info
            const voip = (() => {
                const notes = [];
                let tag = 'good';
                if (avg.voip.MOS >= 4 && avg.voip.latencyMs < 100) notes.push(`MOS ${avg.voip.MOS}, latency ${avg.voip.latencyMs} ms — good`);
                else if (avg.voip.MOS >= 3) { notes.push(`MOS ${avg.voip.MOS}, latency ${avg.voip.latencyMs} ms — fair`); tag = 'ok'; }
                else { notes.push(`MOS ${avg.voip.MOS}, latency ${avg.voip.latencyMs} ms — poor`); tag = 'bad'; }
                if (avg.voip.packetsLost > 1) notes.push(`Packet loss ${avg.voip.packetsLost}%`);
                const worst = seriesMap.voip ? seriesMap.voip.worst : null;
                const worstNote = worst ? `Worst 10s window: ${worst.start.toLocaleTimeString()} → ${worst.end.toLocaleTimeString()}, score: ${worst.score.toFixed(1)}` : '';
                return { text: notes.join('. ') + (worstNote ? '. ' + worstNote : ''), tag, rec: tag === 'bad' ? 'Check AP/packet loss, prioritize voice (QoS), prefer 5GHz.' : tag === 'ok' ? 'Monitor and prioritize voice flows.' : 'No immediate action.' };
            })();

            const local = (() => {
                const notes = []; let tag = 'good';
                if (avg.local.avgBufferAhead >= 10 && avg.local.freezeCount === 0) notes.push(`Smooth playback, avg buffer ${avg.local.avgBufferAhead}s`);
                else if (avg.local.avgBufferAhead >= 5) { notes.push(`Acceptable, avg buffer ${avg.local.avgBufferAhead}s, freezes ${avg.local.freezeCount}`); tag = 'ok'; }
                else { notes.push(`Buffer low ${avg.local.avgBufferAhead}s, freezes ${avg.local.freezeCount}`); tag = 'bad'; }
                const worst = seriesMap.local ? seriesMap.local.worst : null;
                const worstNote = worst ? `Worst 10s: ${worst.start.toLocaleTimeString()} → ${worst.end.toLocaleTimeString()}, sum ${worst.score.toFixed(1)}` : '';
                return { text: notes.join('. ') + (worstNote ? '. ' + worstNote : ''), tag, rec: tag === 'bad' ? 'Improve throughput or buffer ahead, prefer wired/5GHz.' : tag === 'ok' ? 'Monitor spikes.' : 'Good.' };
            })();

            const yt = (() => {
                const notes = []; let tag = 'good';
                if (avg.youtube.freezeCount === 0 && avg.youtube.freezeDuration < 5) notes.push(`YouTube smooth, startup ${avg.youtube.startup} ms`);
                else if (avg.youtube.freezeCount <= 2) { notes.push(`Some rebuffering: ${avg.youtube.freezeCount} freezes, ${avg.youtube.freezeDuration}s`); tag = 'ok'; }
                else { notes.push(`Multiple freezes: ${avg.youtube.freezeCount}, ${avg.youtube.freezeDuration}s`); tag = 'bad'; }
                const worst = seriesMap.youtube ? seriesMap.youtube.worst : null;
                const worstNote = worst ? `Worst 10s: ${worst.start.toLocaleTimeString()} → ${worst.end.toLocaleTimeString()}` : '';
                return { text: notes.join('. ') + (worstNote ? '. ' + worstNote : ''), tag, rec: tag === 'bad' ? 'Investigate CDN, RF or link drops.' : tag === 'ok' ? 'Tune ABR / buffer' : 'Good.' };
            })();

            const sp = (() => {
                const notes = []; let tag = 'good';
                if (avg.speed.download >= 50 && avg.speed.upload >= 10) notes.push(`Fast DL ${avg.speed.download} Mbps / UL ${avg.speed.upload} Mbps`);
                else if (avg.speed.download >= 10) { notes.push(`Moderate speed DL ${avg.speed.download} Mbps`); tag = 'ok'; }
                else { notes.push(`Slow DL ${avg.speed.download} Mbps`); tag = 'bad'; }
                const worst = seriesMap.speed ? seriesMap.speed.worst : null;
                const worstNote = worst ? `Worst 10s: ${worst.start.toLocaleTimeString()} → ${worst.end.toLocaleTimeString()}` : '';
                return { text: notes.join('. ') + (worstNote ? '. ' + worstNote : ''), tag, rec: tag === 'bad' ? 'Check WAN/ISP or peak congestion.' : tag === 'ok' ? 'Monitor peaks' : 'All good.' };
            })();

            return { voip, local, yt, sp };
        }

        /* ------------------------------
          Render logic (handles compare A vs B)
           ------------------------------ */
        function renderForUsers(recordsA, recordsB = null) {
            const main = document.getElementById('mainColumn');
            main.innerHTML = '';

            // compute averages & series for each user
            const avgA = computeAverages(recordsA || []);
            const seriesA = {
                voip: { pts: seriesFor(recordsA, ['voip', 'latencyMs']) },
                mos: { pts: seriesFor(recordsA, ['voip', 'MOS']) },
                localBuffer: { pts: seriesFor(recordsA, ['local', 'avgBufferAhead']) },
                localFreeze: { pts: seriesFor(recordsA, ['local', 'freezeCount']) },
                ytStartup: { pts: seriesFor(recordsA, ['youtube', 'startup']) },
                ytFreezeDur: { pts: seriesFor(recordsA, ['youtube', 'freezeDuration']) },
                speedDL: { pts: seriesFor(recordsA, ['speed', 'download']) },
                speedUL: { pts: seriesFor(recordsA, ['speed', 'upload']) }
            };

            // find worst windows (A)
            const worstA = {
                voip: worstWindow(seriesA.voip.pts, 10),
                mos: worstWindow(seriesA.mos.pts, 10),
                local: worstWindow(seriesA.localFreeze.pts, 10) || worstWindow(seriesA.localBuffer.pts, 10),
                youtube: worstWindow(seriesA.ytFreezeDur.pts, 10),
                speed: worstWindow(seriesA.speedDL.pts, 10) || worstWindow(seriesA.speedUL.pts, 10)
            };

            // if compare present compute same for B
            let avgB = null, seriesB = null, worstB = null;
            if (recordsB) {
                avgB = computeAverages(recordsB || []);
                seriesB = {
                    voip: { pts: seriesFor(recordsB, ['voip', 'latencyMs']) },
                    mos: { pts: seriesFor(recordsB, ['voip', 'MOS']) },
                    localBuffer: { pts: seriesFor(recordsB, ['local', 'avgBufferAhead']) },
                    localFreeze: { pts: seriesFor(recordsB, ['local', 'freezeCount']) },
                    ytStartup: { pts: seriesFor(recordsB, ['youtube', 'startup']) },
                    ytFreezeDur: { pts: seriesFor(recordsB, ['youtube', 'freezeDuration']) },
                    speedDL: { pts: seriesFor(recordsB, ['speed', 'download']) },
                    speedUL: { pts: seriesFor(recordsB, ['speed', 'upload']) }
                };
                worstB = {
                    voip: worstWindow(seriesB.voip.pts, 10),
                    mos: worstWindow(seriesB.mos.pts, 10),
                    local: worstWindow(seriesB.localFreeze.pts, 10) || worstWindow(seriesB.localBuffer.pts, 10),
                    youtube: worstWindow(seriesB.ytFreezeDur.pts, 10),
                    speed: worstWindow(seriesB.speedDL.pts, 10) || worstWindow(seriesB.speedUL.pts, 10)
                };
            }

            // AGGREGATED Overview card (full width)
            function getTagColor(val, thresholds, betterHigh = true) {
                if (val === null || val === undefined) return '';

                if (betterHigh) {
                    if (val >= thresholds.good) return 'good'; // green
                    if (val >= thresholds.ok) return 'ok';     // yellow
                    return 'bad';                             // red
                } else {
                    if (val <= thresholds.good) return 'good';
                    if (val <= thresholds.ok) return 'ok';
                    return 'bad';
                }
            }

            const agg = document.createElement('div');
            agg.className = 'card full';

            function paramBlock(label, value, tag) {
                return `<div style="padding:8px;border-radius:8px;background:var(--card)">
    <div class="small">${label}</div>
    <div style="font-weight:700"><span class="insight-tag ${tag}">${value}</span></div>
  </div>`;
            }

            // define thresholds according to lab standard recommendations
            const thresholds = {
                voipMOS: { good: 4, ok: 3 },                  // higher is better
                latency: { good: 100, ok: 200 },              // lower is better
                jitter: { good: 30, ok: 60 },                 // lower is better
                packetLoss: { good: 1, ok: 3 },               // lower is better
                avgBuffer: { good: 10, ok: 5 },               // higher is better
                freezes: { good: 0, ok: 2 },                  // lower is better
                youtubeStartup: { good: 2000, ok: 5000 },     // lower is better
                youtubeFreeze: { good: 0, ok: 5 },            // lower is better
                download: { good: 50, ok: 10 },               // higher is better
                upload: { good: 10, ok: 5 }                   // higher is better
            };

            agg.innerHTML = `
<h3>Overview</h3>
<div class="meta">Records A: ${recordsA.length} ${recordsB ? `• Records B: ${recordsB.length}` : ''}</div>
<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(130px,1fr));gap:8px;margin-top:10px">
  ${paramBlock('VoIP MOS (A)', avgA.voip.MOS, getTagColor(avgA.voip.MOS, thresholds.voipMOS, true))}
  ${recordsB ? paramBlock('VoIP MOS (B)', avgB.voip.MOS, getTagColor(avgB.voip.MOS, thresholds.voipMOS, true)) : ''}
  
  ${paramBlock('VoIP Latency (A ms)', avgA.voip.latencyMs, getTagColor(avgA.voip.latencyMs, thresholds.latency, false))}
  ${recordsB ? paramBlock('Latency (B ms)', avgB.voip.latencyMs, getTagColor(avgB.voip.latencyMs, thresholds.latency, false)) : ''}
  
  ${paramBlock('VoIP Jitter (A ms)', avgA.voip.jitter, getTagColor(avgA.voip.jitter, thresholds.jitter, false))}
  ${recordsB ? paramBlock('Jitter (B ms)', avgB.voip.jitter, getTagColor(avgB.voip.jitter, thresholds.jitter, false)) : ''}
  
  ${paramBlock('VoIP Packet Loss (A %)', avgA.voip.packetsLost, getTagColor(avgA.voip.packetsLost, thresholds.packetLoss, false))}
  ${recordsB ? paramBlock('Packet Loss (B %)', avgB.voip.packetsLost, getTagColor(avgB.voip.packetsLost, thresholds.packetLoss, false)) : ''}

  ${paramBlock('Local Avg Buffer (A s)', avgA.local.avgBufferAhead, getTagColor(avgA.local.avgBufferAhead, thresholds.avgBuffer, true))}
  ${recordsB ? paramBlock('Local Avg Buffer (B s)', avgB.local.avgBufferAhead, getTagColor(avgB.local.avgBufferAhead, thresholds.avgBuffer, true)) : ''}

  ${paramBlock('Local Freezes (A)', avgA.local.freezeCount, getTagColor(avgA.local.freezeCount, thresholds.freezes, false))}
  ${recordsB ? paramBlock('Local Freezes (B)', avgB.local.freezeCount, getTagColor(avgB.local.freezeCount, thresholds.freezes, false)) : ''}

  ${paramBlock('YouTube Startup (A ms)', avgA.youtube.startup, getTagColor(avgA.youtube.startup, thresholds.youtubeStartup, false))}
  ${recordsB ? paramBlock('YouTube Startup (B ms)', avgB.youtube.startup, getTagColor(avgB.youtube.startup, thresholds.youtubeStartup, false)) : ''}

  ${paramBlock('YouTube Freeze Duration (A ms)', avgA.youtube.freezeDuration, getTagColor(avgA.youtube.freezeDuration, thresholds.youtubeFreeze, false))}
  ${recordsB ? paramBlock('YouTube Freeze Duration (B ms)', avgB.youtube.freezeDuration, getTagColor(avgB.youtube.freezeDuration, thresholds.youtubeFreeze, false)) : ''}

  ${paramBlock('Download (A Mbps)', avgA.speed.download, getTagColor(avgA.speed.download, thresholds.download, true))}
  ${recordsB ? paramBlock('Download (B Mbps)', avgB.speed.download, getTagColor(avgB.speed.download, thresholds.download, true)) : ''}

  ${paramBlock('Upload (A Mbps)', avgA.speed.upload, getTagColor(avgA.speed.upload, thresholds.upload, true))}
  ${recordsB ? paramBlock('Upload (B Mbps)', avgB.speed.upload, getTagColor(avgB.speed.upload, thresholds.upload, true)) : ''}
</div>
<div style="margin-top:10px" class="small">Worst 10s summary shown per section below.</div>
`;

            main.appendChild(agg);




            // Create per-test comparison card generator
            function createComparisonCard(title, canvasIdA, canvasIdB, ptsA, ptsB, yLabel, worstAwin, worstBwin, summaryA, summaryB) {
                const card = document.createElement('div'); card.className = 'card';
                card.innerHTML = `
      <h3>${title}</h3>
      <div class="two-col">
        <div>
          <div class="meta">User A</div>
          <canvas id="${canvasIdA}"></canvas>
          <div class="summary" id="${canvasIdA}-summary"></div>
        </div>
        <div>
          <div class="meta">User B</div>
          <canvas id="${canvasIdB}"></canvas>
          <div class="summary" id="${canvasIdB}-summary"></div>
        </div>
      </div>
    `;
                return { card, ptsA, ptsB, canvasIdA, canvasIdB, yLabel, worstAwin, worstBwin, summaryA, summaryB };
            }

            // VOIP comparison (latency + MOS)
            const voipComp = createComparisonCard('VoIP — Latency / MOS', 'voipA', 'voipB', seriesA.voip.pts, (seriesB ? seriesB.voip.pts : []), 'ms', worstA.voip, worstB ? worstB.voip : null,
                null, null);
            main.appendChild(voipComp.card);
            // draw charts
            drawLine(voipComp.canvasIdA, seriesA.voip.pts, 'Latency', 'ms', worstA.voip, '#3b82f6');
            if (recordsB) drawLine(voipComp.canvasIdB, seriesB.voip.pts, 'Latency', 'ms', worstB.voip, '#ef4444'); else {
                // blank B canvas
                const bcan = document.getElementById(voipComp.canvasIdB);
                if (bcan) { if (bcan._chart) try { bcan._chart.destroy(); } catch (e) { }; bcan.getContext('2d').clearRect(0, 0, bcan.width, bcan.height); bcan.parentElement.querySelector('.small')?.remove?.(); }
            }
            // summaries for voip
            const summariesA = makeSummaries(avgA, { voip: { worst: worstA.voip }, local: { worst: worstA.local }, youtube: { worst: worstA.youtube }, speed: { worst: worstA.speed } });
            const summariesB = recordsB ? makeSummaries(avgB, { voip: { worst: worstB.voip }, local: { worst: worstB.local }, youtube: { worst: worstB.youtube }, speed: { worst: worstB.speed } }) : null;
            document.getElementById(voipComp.canvasIdA + '-summary').innerHTML = `<div class="score">${summariesA.voip.text}</div><div class="recommend">Rec: ${summariesA.voip.rec}</div><div style="margin-top:6px"><span class="insight-tag ${summariesA.voip.tag === 'good' ? 'good' : (summariesA.voip.tag === 'ok' ? 'ok' : 'bad')}">${summariesA.voip.tag.toUpperCase()}</span></div>`;
            if (summariesB) document.getElementById(voipComp.canvasIdB + '-summary').innerHTML = `<div class="score">${summariesB.voip.text}</div><div class="recommend">Rec: ${summariesB.voip.rec}</div><div style="margin-top:6px"><span class="insight-tag ${summariesB.voip.tag === 'good' ? 'good' : (summariesB.voip.tag === 'ok' ? 'ok' : 'bad')}">${summariesB.voip.tag.toUpperCase()}</span></div>`;

            // LOCAL comparison (buffer & freezes)
            const localComp = createComparisonCard('Local Video — Buffer & Freezes', 'localA', 'localB', seriesA.localBuffer.pts, seriesB ? seriesB.localBuffer.pts : [], 's', worstA.local, worstB ? worstB.local : null);
            main.appendChild(localComp.card);
            drawLine(localComp.canvasIdA, seriesA.localBuffer.pts, 'Avg Buffer Ahead (s)', 's', worstA.local, '#10b981');
            if (recordsB) drawLine(localComp.canvasIdB, seriesB.localBuffer.pts, 'Avg Buffer Ahead (s)', 's', worstB.local, '#ef4444');
            document.getElementById(localComp.canvasIdA + '-summary').innerHTML = `<div class="score">${summariesA.local.text}</div><div class="recommend">Rec: ${summariesA.local.rec}</div><div style="margin-top:6px"><span class="insight-tag ${summariesA.local.tag === 'good' ? 'good' : (summariesA.local.tag === 'ok' ? 'ok' : 'bad')}">${summariesA.local.tag.toUpperCase()}</span></div>`;
            if (summariesB) document.getElementById(localComp.canvasIdB + '-summary').innerHTML = `<div class="score">${summariesB.local.text}</div><div class="recommend">Rec: ${summariesB.local.rec}</div><div style="margin-top:6px"><span class="insight-tag ${summariesB.local.tag === 'good' ? 'good' : (summariesB.local.tag === 'ok' ? 'ok' : 'bad')}">${summariesB.local.tag.toUpperCase()}</span></div>`;

            // YOUTUBE comparison
            const ytComp = createComparisonCard('YouTube — Startup & Freeze Dur', 'ytA', 'ytB', seriesA.ytStartup.pts, seriesB ? seriesB.ytStartup.pts : [], 'ms', worstA.youtube, worstB ? worstB.youtube : null);
            main.appendChild(ytComp.card);
            drawLine(ytComp.canvasIdA, seriesA.ytStartup.pts, 'Startup (ms)', 'ms', worstA.youtube, '#6366f1');
            if (recordsB) drawLine(ytComp.canvasIdB, seriesB.ytStartup.pts, 'Startup (ms)', 'ms', worstB.youtube, '#ef4444');
            document.getElementById(ytComp.canvasIdA + '-summary').innerHTML = `<div class="score">${summariesA.yt.text}</div><div class="recommend">Rec: ${summariesA.yt.rec}</div><div style="margin-top:6px"><span class="insight-tag ${summariesA.yt.tag === 'good' ? 'good' : (summariesA.yt.tag === 'ok' ? 'ok' : 'bad')}">${summariesA.yt.tag.toUpperCase()}</span></div>`;
            if (summariesB) document.getElementById(ytComp.canvasIdB + '-summary').innerHTML = `<div class="score">${summariesB.yt.text}</div><div class="recommend">Rec: ${summariesB.yt.rec}</div><div style="margin-top:6px"><span class="insight-tag ${summariesB.yt.tag === 'good' ? 'good' : (summariesB.yt.tag === 'ok' ? 'ok' : 'bad')}">${summariesB.yt.tag.toUpperCase()}</span></div>`;

            // SPEED comparison
            const speedComp = createComparisonCard('Speed — Download / Upload', 'spdA', 'spdB', seriesA.speedDL.pts, seriesB ? seriesB.speedDL.pts : [], 'Mbps', worstA.speed, worstB ? worstB.speed : null);
            main.appendChild(speedComp.card);
            drawLine(speedComp.canvasIdA, seriesA.speedDL.pts, 'Download (Mbps)', 'Mbps', worstA.speed, '#06b6d4');
            if (recordsB) drawLine(speedComp.canvasIdB, seriesB.speedDL.pts, 'Download (Mbps)', 'Mbps', worstB.speed, '#ef4444');
            document.getElementById(speedComp.canvasIdA + '-summary').innerHTML = `<div class="score">${summariesA.sp.text}</div><div class="recommend">Rec: ${summariesA.sp.rec}</div><div style="margin-top:6px"><span class="insight-tag ${summariesA.sp.tag === 'good' ? 'good' : (summariesA.sp.tag === 'ok' ? 'ok' : 'bad')}">${summariesA.sp.tag.toUpperCase()}</span></div>`;
            if (summariesB) document.getElementById(speedComp.canvasIdB + '-summary').innerHTML = `<div class="score">${summariesB.sp.text}</div><div class="recommend">Rec: ${summariesB.sp.rec}</div><div style="margin-top:6px"><span class="insight-tag ${summariesB.sp.tag === 'good' ? 'good' : (summariesB.sp.tag === 'ok' ? 'ok' : 'bad')}">${summariesB.sp.tag.toUpperCase()}</span></div>`;

            // update side snapshot
            const snap = document.getElementById('snapshot');
            let shtml = `<div><strong>User A</strong>: ${recordsA.length} records</div>`;
            if (recordsB) shtml += `<div><strong>User B</strong>: ${recordsB.length} records</div>`;
            snap.innerHTML = shtml;
        }

        /* ------------------------------
          Filters & Data load
           ------------------------------ */
        async function loadData() {
            // Show loader immediately
            const loader = document.getElementById("loader");
            if (loader) loader.style.display = "flex";

            try {
                const res = await fetch(API_URL);
                allData = await res.json();
                populateUsers();
                applyFilters();
            } catch (e) {
                console.error(e);
                document.getElementById('mainColumn').innerHTML = `
            <div class="card full">
                <h3>Error loading data</h3>
                <div class="meta">Check network / API</div>
            </div>`;
            }

            // Smooth fade-out loader once everything is rendered
            if (loader) {
                loader.style.transition = "opacity 0.3s ease";
                loader.style.opacity = "0";
                setTimeout(() => {
                    loader.style.display = "none";
                }, 300);
            }
        }


        function populateUsers() {
            const users = [...new Set(allData.map(d => d.email).filter(Boolean))].sort();
            const a = document.getElementById('userA');
            const b = document.getElementById('userB');
            a.innerHTML = '<option value="all">All Users</option>';
            b.innerHTML = '<option value="none">None</option><option value="all">All Users</option>';
            users.forEach(u => {
                const o1 = document.createElement('option'); o1.value = u; o1.text = u; a.appendChild(o1);
                const o2 = document.createElement('option'); o2.value = u; o2.text = u; b.appendChild(o2);
            });
            a.value = 'all'; b.value = 'none';
        }

        function applyFilters() {
            const ua = document.getElementById('userA').value;
            const ub = document.getElementById('userB').value;
            const from = document.getElementById('fromDate').value;
            const to = document.getElementById('toDate').value;
            let filtered = allData.slice();

            if (ua && ua !== 'all') filtered = filtered.filter(r => r.email === ua);
            if (from) {
                const s = new Date(from); s.setHours(0, 0, 0, 0);
                filtered = filtered.filter(r => { const t = toDate(r.ts); return t && t >= s; });
            }
            if (to) {
                const e = new Date(to); e.setHours(23, 59, 59, 999);
                filtered = filtered.filter(r => { const t = toDate(r.ts); return t && t <= e; });
            }

            let recordsA = filtered;
            // if userA != 'all' and userA set, filter recordsA to that user only
            if (ua && ua !== 'all') recordsA = allData.filter(r => r.email === ua).filter(r => {
                if (from) { const s = new Date(from); s.setHours(0, 0, 0, 0); if (!(toDate(r.ts) && toDate(r.ts) >= s)) return false; }
                if (to) { const e = new Date(to); e.setHours(23, 59, 59, 999); if (!(toDate(r.ts) && toDate(r.ts) <= e)) return false; }
                return true;
            });

            let recordsB = null;
            if (ub && ub !== 'none') {
                recordsB = allData.filter(r => (ub === 'all' ? true : r.email === ub)).filter(r => {
                    if (from) { const s = new Date(from); s.setHours(0, 0, 0, 0); if (!(toDate(r.ts) && toDate(r.ts) >= s)) return false; }
                    if (to) { const e = new Date(to); e.setHours(23, 59, 59, 999); if (!(toDate(r.ts) && toDate(r.ts) <= e)) return false; }
                    return true;
                });
            }

            renderForUsers(recordsA || [], recordsB);
        }
        // CSV download (flatten nested objects)
        function downloadCSV(data = allData) {
            const headers = [
                "_id", "email", "ts",
                "voip_ts", "voip_latencyMs", "voip_avgJitterMs", "voip_packetsReceived", "voip_packetsLost", "voip_lossPercent", "voip_MOS", "voip_dcSamples",
                "local_ts", "local_startup", "local_stalls", "local_totalStall", "local_freezeCount", "local_freezeDuration", "local_avgBufferAhead", "local_minBufferAhead", "local_maxBufferAhead", "local_bufferRatio", "local_avgStallDuration",
                "youtube_ts", "youtube_startup", "youtube_stalls", "youtube_totalStall", "youtube_freezeCount", "youtube_freezeDuration", "youtube_avgBufferAhead", "youtube_minBufferAhead", "youtube_maxBufferAhead", "youtube_bufferRatio",
                "speed_download", "speed_upload", "speed_simulated"
            ];

            const csvRows = [headers.join(",")];

            data.forEach(row => {
                const values = [
                    row._id || '', row.email || '', row.ts || '',
                    getVal(row.voip, ['ts']), getVal(row.voip, ['latencyMs', 'latency']), getVal(row.voip, ['avgJitterMs', 'jitter']),
                    getVal(row.voip, ['packetsReceived']), getVal(row.voip, ['packetsLost']), getVal(row.voip, ['lossPercent']),
                    getVal(row.voip, ['MOS', 'mos']), getVal(row.voip, ['dcSamples']),

                    getVal(row.local, ['ts']), getVal(row.local, ['startup']), getVal(row.local, ['stalls', 'freezeCount']),
                    getVal(row.local, ['totalStall']), getVal(row.local, ['freezeCount', 'stalls']), getVal(row.local, ['freezeDuration']),
                    getVal(row.local, ['avgBufferAhead']), getVal(row.local, ['minBufferAhead']), getVal(row.local, ['maxBufferAhead']),
                    getVal(row.local, ['bufferRatio']), getVal(row.local, ['avgStallDuration']),

                    getVal(row.youtube, ['ts']), getVal(row.youtube, ['startup']), getVal(row.youtube, ['stalls', 'freezeCount']),
                    getVal(row.youtube, ['totalStall']), getVal(row.youtube, ['freezeCount', 'stalls']), getVal(row.youtube, ['freezeDuration']),
                    getVal(row.youtube, ['avgBufferAhead']), getVal(row.youtube, ['minBufferAhead']), getVal(row.youtube, ['maxBufferAhead']),
                    getVal(row.youtube, ['bufferRatio']),

                    getVal(row.speed, ['download']), getVal(row.speed, ['upload']), getVal(row.speed, ['simulated'])
                ];

                // Escape quotes and wrap values in quotes
                const escapedValues = values.map(v => `"${String(v).replace(/"/g, '""')}"`);
                csvRows.push(escapedValues.join(","));
            });

            const blob = new Blob([csvRows.join("\n")], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'qoe_data.csv';
            a.click();
            URL.revokeObjectURL(url);
        }





        /* ------------------------------
          PDF export (jsPDF)
           - collects visible canvases and summaries and places them into PDF
           ------------------------------ */
        async function exportPDF() {
            const { jsPDF } = window.jspdf;
            const pdf = new jsPDF({ orientation: 'portrait', unit: 'pt', format: 'a4' });
            const margin = 40;
            let y = margin;
            // header
            pdf.setFontSize(16); pdf.text("Network QoE Report", margin, y); y += 18;
            pdf.setFontSize(10); pdf.text("Generated: " + new Date().toLocaleString(), margin, y); y += 18;

            // gather canvases in the main column (query all canvas)
            const canvases = Array.from(document.querySelectorAll('#mainColumn canvas'));
            for (const c of canvases) {
                // render canvas as image
                try {
                    const dataUrl = c.toDataURL('image/png', 0.9);
                    const imgW = 500;
                    const imgH = (c.height / c.width) * imgW;
                    if (y + imgH > 800) { pdf.addPage(); y = margin; }
                    pdf.addImage(dataUrl, 'PNG', margin, y, imgW, imgH);
                    y += imgH + 8;
                } catch (e) {
                    console.warn('pdf canvas error', e);
                }
            }

            // append textual summaries (collect .summary content)
            const summaries = Array.from(document.querySelectorAll('#mainColumn .summary'));
            pdf.setFontSize(12);
            summaries.forEach(s => {
                const txt = s.innerText || s.textContent;
                if (!txt) return;
                if (y + 60 > 800) { pdf.addPage(); y = margin; }
                pdf.text(txt.split('\\n').map(l => l.trim()).filter(Boolean).join(' — '), margin, y, { maxWidth: 500 });
                y += 40;
            });

            pdf.save('qoe_report.pdf');
        }

        /* ------------------------------
          Events wiring
           ------------------------------ */
        document.getElementById('applyFilters').addEventListener('click', () => applyFilters());
        document.getElementById('resetFilters').addEventListener('click', () => {
            document.getElementById('fromDate').value = '';
            document.getElementById('toDate').value = '';
            document.getElementById('userA').value = 'all';
            document.getElementById('userB').value = 'none';
            applyFilters();
        });
        document.getElementById('downloadCsv').addEventListener('click', () => downloadCSV());
        document.getElementById('exportPdf').addEventListener('click', () => exportPDF());
        document.getElementById('refresh').addEventListener('click', () => loadData());

        /* ------------------------------
          Initial load
           ------------------------------ */
        loadData();
    </script>
</body>

</html>
